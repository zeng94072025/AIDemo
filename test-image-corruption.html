<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>圖片損壞測試</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .test-section {
            background: white;
            margin: 20px 0;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .canvas-container {
            display: flex;
            gap: 20px;
            margin: 20px 0;
        }
        canvas {
            border: 1px solid #ccc;
            max-width: 300px;
            max-height: 300px;
        }
        .test-result {
            background: #f0f0f0;
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-family: monospace;
        }
        .error {
            background: #ffe6e6;
            color: #d32f2f;
        }
        .success {
            background: #e6ffe6;
            color: #2e7d32;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background: #0056b3;
        }
        input[type="file"] {
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <h1>圖片損壞問題診斷工具</h1>
    
    <div class="test-section">
        <h2>測試 1: 原始圖片顯示</h2>
        <input type="file" id="testFile" accept="image/*">
        <div class="canvas-container">
            <div>
                <h3>原始圖片</h3>
                <img id="originalImage" style="max-width: 300px; max-height: 300px;">
            </div>
            <div>
                <h3>Canvas 繪製 (當前方式)</h3>
                <canvas id="currentCanvas" width="300" height="300"></canvas>
            </div>
            <div>
                <h3>Canvas 繪製 (修正方式)</h3>
                <canvas id="fixedCanvas" width="300" height="300"></canvas>
            </div>
        </div>
        <button onclick="testCurrentMethod()">測試當前繪製方式</button>
        <button onclick="testFixedMethod()">測試修正繪製方式</button>
        <div id="test1Result" class="test-result"></div>
    </div>

    <div class="test-section">
        <h2>測試 2: Blob 生成比較</h2>
        <button onclick="testBlobGeneration()">測試 Blob 生成</button>
        <div id="test2Result" class="test-result"></div>
    </div>

    <div class="test-section">
        <h2>測試 3: 下載測試</h2>
        <button onclick="testDownload()">測試下載功能</button>
        <div id="test3Result" class="test-result"></div>
    </div>

    <div class="test-section">
        <h2>測試 4: 完整流程測試</h2>
        <button onclick="testFullWorkflow()">測試完整流程</button>
        <div id="test4Result" class="test-result"></div>
    </div>

    <script>
        let testFile = null;
        let originalImage = null;

        // 文件選擇處理
        document.getElementById('testFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                testFile = file;
                displayOriginalImage(file);
            }
        });

        // 顯示原始圖片
        function displayOriginalImage(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = document.getElementById('originalImage');
                img.src = e.target.result;
                originalImage = img;
            };
            reader.readAsDataURL(file);
        }

        // 測試當前繪製方式（可能有問題的方式）
        function testCurrentMethod() {
            if (!testFile || !originalImage) {
                showResult('test1Result', '請先選擇圖片文件', 'error');
                return;
            }

            const canvas = document.getElementById('currentCanvas');
            const ctx = canvas.getContext('2d');
            
            // 清空 Canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 使用當前方式繪製（拉伸到 Canvas 尺寸）
            ctx.drawImage(originalImage, 0, 0, canvas.width, canvas.height);
            
            // 檢查繪製結果
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const hasContent = imageData.data.some(pixel => pixel !== 0);
            
            const result = {
                method: '當前方式',
                canvasSize: `${canvas.width}x${canvas.height}`,
                imageSize: `${originalImage.naturalWidth}x${originalImage.naturalHeight}`,
                hasContent: hasContent,
                nonZeroPixels: imageData.data.filter(pixel => pixel !== 0).length,
                totalPixels: imageData.data.length / 4
            };
            
            showResult('test1Result', JSON.stringify(result, null, 2), hasContent ? 'success' : 'error');
        }

        // 測試修正繪製方式
        function testFixedMethod() {
            if (!testFile || !originalImage) {
                showResult('test1Result', '請先選擇圖片文件', 'error');
                return;
            }

            const canvas = document.getElementById('fixedCanvas');
            const ctx = canvas.getContext('2d');
            
            // 清空 Canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 計算適當的繪製尺寸，保持比例
            const imgAspect = originalImage.naturalWidth / originalImage.naturalHeight;
            const canvasAspect = canvas.width / canvas.height;
            
            let drawWidth, drawHeight, offsetX, offsetY;
            
            if (imgAspect > canvasAspect) {
                // 圖片更寬，以寬度為準
                drawWidth = canvas.width;
                drawHeight = canvas.width / imgAspect;
                offsetX = 0;
                offsetY = (canvas.height - drawHeight) / 2;
            } else {
                // 圖片更高，以高度為準
                drawHeight = canvas.height;
                drawWidth = canvas.height * imgAspect;
                offsetX = (canvas.width - drawWidth) / 2;
                offsetY = 0;
            }
            
            // 使用修正方式繪製（保持比例）
            ctx.drawImage(originalImage, offsetX, offsetY, drawWidth, drawHeight);
            
            // 檢查繪製結果
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const hasContent = imageData.data.some(pixel => pixel !== 0);
            
            const result = {
                method: '修正方式',
                canvasSize: `${canvas.width}x${canvas.height}`,
                imageSize: `${originalImage.naturalWidth}x${originalImage.naturalHeight}`,
                drawSize: `${drawWidth}x${drawHeight}`,
                offset: `${offsetX},${offsetY}`,
                hasContent: hasContent,
                nonZeroPixels: imageData.data.filter(pixel => pixel !== 0).length,
                totalPixels: imageData.data.length / 4
            };
            
            showResult('test1Result', JSON.stringify(result, null, 2), hasContent ? 'success' : 'error');
        }

        // 測試 Blob 生成
        async function testBlobGeneration() {
            if (!testFile) {
                showResult('test2Result', '請先選擇圖片文件', 'error');
                return;
            }

            const results = [];
            
            // 測試當前方式
            const currentCanvas = document.getElementById('currentCanvas');
            const currentCtx = currentCanvas.getContext('2d');
            currentCtx.clearRect(0, 0, currentCanvas.width, currentCanvas.height);
            currentCtx.drawImage(originalImage, 0, 0, currentCanvas.width, currentCanvas.height);
            
            try {
                const currentBlob = await canvasToBlob(currentCanvas, 'image/jpeg', 0.9);
                results.push({
                    method: '當前方式',
                    blobSize: currentBlob.size,
                    blobType: currentBlob.type,
                    success: true
                });
            } catch (error) {
                results.push({
                    method: '當前方式',
                    error: error.message,
                    success: false
                });
            }
            
            // 測試修正方式
            const fixedCanvas = document.getElementById('fixedCanvas');
            const fixedCtx = fixedCanvas.getContext('2d');
            fixedCtx.clearRect(0, 0, fixedCanvas.width, fixedCanvas.height);
            
            const imgAspect = originalImage.naturalWidth / originalImage.naturalHeight;
            const canvasAspect = fixedCanvas.width / fixedCanvas.height;
            
            let drawWidth, drawHeight, offsetX, offsetY;
            
            if (imgAspect > canvasAspect) {
                drawWidth = fixedCanvas.width;
                drawHeight = fixedCanvas.width / imgAspect;
                offsetX = 0;
                offsetY = (fixedCanvas.height - drawHeight) / 2;
            } else {
                drawHeight = fixedCanvas.height;
                drawWidth = fixedCanvas.height * imgAspect;
                offsetX = (fixedCanvas.width - drawWidth) / 2;
                offsetY = 0;
            }
            
            fixedCtx.drawImage(originalImage, offsetX, offsetY, drawWidth, drawHeight);
            
            try {
                const fixedBlob = await canvasToBlob(fixedCanvas, 'image/jpeg', 0.9);
                results.push({
                    method: '修正方式',
                    blobSize: fixedBlob.size,
                    blobType: fixedBlob.type,
                    success: true
                });
            } catch (error) {
                results.push({
                    method: '修正方式',
                    error: error.message,
                    success: false
                });
            }
            
            showResult('test2Result', JSON.stringify(results, null, 2), 'info');
        }

        // Canvas 轉 Blob 輔助函數
        function canvasToBlob(canvas, type, quality) {
            return new Promise((resolve, reject) => {
                canvas.toBlob((blob) => {
                    if (blob && blob.size > 0) {
                        resolve(blob);
                    } else {
                        reject(new Error('生成的 Blob 無效或為空'));
                    }
                }, type, quality);
            });
        }

        // 測試下載功能
        async function testDownload() {
            if (!testFile) {
                showResult('test3Result', '請先選擇圖片文件', 'error');
                return;
            }

            const results = [];
            
            // 測試當前方式下載
            const currentCanvas = document.getElementById('currentCanvas');
            const currentCtx = currentCanvas.getContext('2d');
            currentCtx.clearRect(0, 0, currentCanvas.width, currentCanvas.height);
            currentCtx.drawImage(originalImage, 0, 0, currentCanvas.width, currentCanvas.height);
            
            try {
                const currentBlob = await canvasToBlob(currentCanvas, 'image/jpeg', 0.9);
                downloadBlob(currentBlob, 'test_current_method.jpg');
                results.push({
                    method: '當前方式',
                    filename: 'test_current_method.jpg',
                    blobSize: currentBlob.size,
                    success: true
                });
            } catch (error) {
                results.push({
                    method: '當前方式',
                    error: error.message,
                    success: false
                });
            }
            
            // 測試修正方式下載
            const fixedCanvas = document.getElementById('fixedCanvas');
            const fixedCtx = fixedCanvas.getContext('2d');
            fixedCtx.clearRect(0, 0, fixedCanvas.width, fixedCanvas.height);
            
            const imgAspect = originalImage.naturalWidth / originalImage.naturalHeight;
            const canvasAspect = fixedCanvas.width / fixedCanvas.height;
            
            let drawWidth, drawHeight, offsetX, offsetY;
            
            if (imgAspect > canvasAspect) {
                drawWidth = fixedCanvas.width;
                drawHeight = fixedCanvas.width / imgAspect;
                offsetX = 0;
                offsetY = (fixedCanvas.height - drawHeight) / 2;
            } else {
                drawHeight = fixedCanvas.height;
                drawWidth = fixedCanvas.height * imgAspect;
                offsetX = (fixedCanvas.width - drawWidth) / 2;
                offsetY = 0;
            }
            
            fixedCtx.drawImage(originalImage, offsetX, offsetY, drawWidth, drawHeight);
            
            try {
                const fixedBlob = await canvasToBlob(fixedCanvas, 'image/jpeg', 0.9);
                downloadBlob(fixedBlob, 'test_fixed_method.jpg');
                results.push({
                    method: '修正方式',
                    filename: 'test_fixed_method.jpg',
                    blobSize: fixedBlob.size,
                    success: true
                });
            } catch (error) {
                results.push({
                    method: '修正方式',
                    error: error.message,
                    success: false
                });
            }
            
            showResult('test3Result', JSON.stringify(results, null, 2), 'info');
        }

        // 下載 Blob 輔助函數
        function downloadBlob(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.style.display = 'none';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            setTimeout(() => URL.revokeObjectURL(url), 1000);
        }

        // 完整流程測試
        async function testFullWorkflow() {
            if (!testFile) {
                showResult('test4Result', '請先選擇圖片文件', 'error');
                return;
            }

            const results = [];
            
            try {
                // 模擬完整的圖片處理流程
                const base64 = await fileToBase64(testFile);
                const img = await createImageElement(base64);
                
                // 創建處理器
                const processor = {
                    canvas: document.createElement('canvas'),
                    ctx: null,
                    setupCanvas: function(width, height) {
                        this.canvas.width = width;
                        this.canvas.height = height;
                        this.ctx = this.canvas.getContext('2d');
                    },
                    drawImage: function(img) {
                        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                        this.ctx.drawImage(img, 0, 0, this.canvas.width, this.canvas.height);
                    },
                    toBlob: function(type, quality) {
                        return new Promise((resolve, reject) => {
                            this.canvas.toBlob((blob) => {
                                if (blob && blob.size > 0) {
                                    resolve(blob);
                                } else {
                                    reject(new Error('生成的 Blob 無效'));
                                }
                            }, type, quality);
                        });
                    }
                };
                
                // 設置 Canvas（使用原始尺寸）
                processor.setupCanvas(img.naturalWidth, img.naturalHeight);
                processor.drawImage(img);
                
                // 生成 Blob
                const blob = await processor.toBlob('image/jpeg', 0.9);
                
                // 下載測試
                downloadBlob(blob, 'test_full_workflow.jpg');
                
                results.push({
                    step: '完整流程測試',
                    originalSize: `${img.naturalWidth}x${img.naturalHeight}`,
                    canvasSize: `${processor.canvas.width}x${processor.canvas.height}`,
                    blobSize: blob.size,
                    success: true
                });
                
            } catch (error) {
                results.push({
                    step: '完整流程測試',
                    error: error.message,
                    success: false
                });
            }
            
            showResult('test4Result', JSON.stringify(results, null, 2), 'info');
        }

        // 輔助函數
        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        function createImageElement(src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = src;
            });
        }

        function showResult(elementId, message, type) {
            const element = document.getElementById(elementId);
            element.textContent = message;
            element.className = `test-result ${type}`;
        }
    </script>
</body>
</html> 